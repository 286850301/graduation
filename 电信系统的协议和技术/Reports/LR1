import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

# 802.11ac参数配置
frequency = 5e9           # 5 GHz 频段
bandwidth = 20e6           # 信道带宽
sampling_rate = 20e6        # 采样率
n_tx_antennas = 2          # 发射天线数
n_rx_antennas = 2          # 接收天线数
fft_size = 64               # FFT 大小
data_carriers = 48          # 数据子载波数
pilot_carriers = 4           # 导频子载波数
mod_order = 16               # 调制阶数 (16QAM)
guard_interval = 0.8e-6      # 保护间隔
distance = 10                # 传输距离 (米)
noise_figure = 10             # 噪声系数 (dB)
kT = 1.38e-23 * 290         # 热噪声功率谱密度

# 子载波索引定义
all_active_indices = list(range(7, 33)) + list(range(34, 60))
pilot_indices = [12, 26, 40, 54]
data_indices = [idx for idx in all_active_indices if idx not in pilot_indices]

print(f"数据子载波数量: {len(data_indices)}")
print(f"导频子载波数量: {len(pilot_indices)}")
print(f"总活跃子载波数: {len(all_active_indices)}\n")

def qam_modulate(bits, mod_order):
    """16-QAM调制函数"""
    if mod_order != 16:
        raise ValueError("只支持16-QAM调制")
    
    # 16-QAM星座图
    constellation = np.array([
        -3-3j, -3-1j, -3+3j, -3+1j,
        -1-3j, -1-1j, -1+3j, -1+1j,
         3-3j,  3-1j,  3+3j,  3+1j,
        -1+3j, -1+1j,  3+3j,  3+1j
    ]) / np.sqrt(10)
    
    # 将比特模式转换为十进制索引
    bits_per_symbol = int(np.log2(mod_order))
    reshaped_bits = bits.reshape(-1, bits_per_symbol)
    
    indices = []
    for symbol_bits in reshaped_bits:
        decimal_value = 0
        for bit in symbol_bits:
            decimal_value = (decimal_value << 1) | int(bit)
        indices.append(decimal_value)
    
    return constellation[indices]

def generate_ofdm_signal(data_bits):
    """OFDM信号生成函数"""
    print("在OFDM生成函数中:")
    print(f"  - 数据子载波索引数量: {len(data_indices)}")
    print(f"  - 导频子载波索引数量: {len(pilot_indices)}")
    
    # 生成导频符号 (BPSK)
    pilot_bits = np.random.randint(0, 2, pilot_carriers)
    
    # 简单BPSK调制
    pilot_symbols = 2 * pilot_bits - 1
    
    # 计算所需比特数
    bits_per_symbol = int(np.log2(mod_order))
    required_bits = len(data_indices) * bits_per_symbol
    
    if len(data_bits) < required_bits:
        raise ValueError(f"数据比特不足！需要 {required_bits} 个，只有 {len(data_bits)} 个")
    
    # 使用16-QAM调制
    modulated_data = qam_modulate(data_bits[:required_bits], mod_order)
    
    print(f"  - 调制数据符号数量: {len(modulated_data)}")
    print(f"  - 数据子载波位置数量: {len(data_indices)}")
    
    # 创建子载波数组
    subcarriers = np.zeros(fft_size, dtype=complex)
    
    # 映射到子载波 (转换为0-based indexing)
    data_indices_0based = [idx - 1 for idx in data_indices]
    pilot_indices_0based = [idx - 1 for idx in pilot_indices]
    
    # 验证维度匹配
    if len(data_indices_0based) != len(modulated_data):
        error_msg = f"维度不匹配: 数据索引={len(data_indices_0based)}, 调制符号={len(modulated_data)}"
        raise ValueError(error_msg)
    
    # 映射到子载波
    subcarriers[data_indices_0based] = modulated_data
    subcarriers[pilot_indices_0based] = pilot_symbols
    
    # IFFT变换
    ofdm_time = np.fft.ifft(subcarriers, fft_size)
    
    # 添加循环前缀
    cp_length = int(round(guard_interval * sampling_rate))
    
    # 添加循环前缀
    ofdm_symbol = np.concatenate([ofdm_time[-cp_length:], ofdm_time])
    
    print("OFDM符号生成完成:")
    print(f"  - 循环前缀长度: {cp_length} 采样点")
    print(f"  - 总符号长度: {len(ofdm_symbol)} 采样点")
    
    return ofdm_symbol, pilot_symbols, subcarriers

def plot_ofdm_signal(ofdm_symbol, subcarriers):
    """绘制OFDM信号的时域和频域图形"""
    cp_length = int(round(guard_interval * sampling_rate))
    symbol_length = len(ofdm_symbol)
    
    # 创建时间轴
    time_axis = np.arange(symbol_length) / sampling_rate * 1e6  # 微秒
    
    # 创建子图
    plt.figure(figsize=(12, 8))
    
    # 1. 时域信号 - 实部
    plt.subplot(2, 2, 1)
    plt.plot(time_axis, np.real(ofdm_symbol))
    plt.axvline(x=time_axis[cp_length], color='r', linestyle='--', label='CP结束')
    plt.xlabel('时间 (微秒)')
    plt.ylabel('幅度')
    plt.title('OFDM时域信号 (实部)')
    plt.grid(True)
    plt.legend()
    
    # 2. 时域信号 - 虚部
    plt.subplot(2, 2, 2)
    plt.plot(time_axis, np.imag(ofdm_symbol))
    plt.axvline(x=time_axis[cp_length], color='r', linestyle='--', label='CP结束')
    plt.xlabel('时间 (微秒)')
    plt.ylabel('幅度')
    plt.title('OFDM时域信号 (虚部)')
    plt.grid(True)
    plt.legend()
    
    # 3. 频域信号 - 幅度谱
    plt.subplot(2, 2, 3)
    freq_axis = np.fft.fftfreq(fft_size, 1/sampling_rate) / 1e6  # MHz
    plt.stem(freq_axis, np.abs(subcarriers), basefmt=" ")
    plt.xlabel('频率 (MHz)')
    plt.ylabel('幅度')
    plt.title('OFDM频域信号 (子载波分配)')
    plt.grid(True)
    
    # 4. 星座图
    plt.subplot(2, 2, 4)
    # 提取数据子载波
    data_indices_0based = [idx - 1 for idx in data_indices]
    data_symbols = subcarriers[data_indices_0based]
    plt.scatter(np.real(data_symbols), np.imag(data_symbols), alpha=0.7)
    plt.xlabel('同相分量 (I)')
    plt.ylabel('正交分量 (Q)')
    plt.title('16-QAM星座图')
    plt.grid(True)
    plt.axis('equal')
    
    plt.tight_layout()
    plt.show()

def main():
    """主函数"""
    print("=== 802.11ac 系统仿真 (Python版) ===\n")
    
    # 生成测试数据
    bits_per_symbol = int(np.log2(mod_order))
    total_data_bits_needed = data_carriers * bits_per_symbol
    data_bits = np.random.randint(0, 2, total_data_bits_needed)
    
    print(f"调制方式: {mod_order}-QAM")
    print(f"FFT大小: {fft_size}")
    print(f"数据子载波数: {data_carriers}")
    print(f"导频子载波数: {pilot_carriers}")
    
    # 生成OFDM信号
    ofdm_symbol, pilot_symbols, subcarriers = generate_ofdm_signal(data_bits)
    
    # 绘制信号
    plot_ofdm_signal(ofdm_symbol, subcarriers)
    
    return ofdm_symbol, pilot_symbols, subcarriers

if __name__ == "__main__":
    # 运行仿真
    try:
        ofdm_symbol, pilot_symbols, subcarriers = main()
        print("\n仿真成功完成!")
    except Exception as e:
        print(f"\n仿真过程中出现错误: {e}")
        import traceback
        traceback.print_exc()
